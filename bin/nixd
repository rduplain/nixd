#!/bin/bash
# nixd v0.3-dev: self-contained configuration management.
#
# Copyright (c) 2012, Ron DuPlain
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# User-configurable environment variables.
declare NIXD_MIRROR # Set to URL pointing to NIXD_SRC directory on mirror.

# Environment variables passed to package scripts. Declare now, set later.
declare NIXD_PREFIX # prefix to use in installation, absolute nixd/usr (static)
declare NIXD_BIN    # path to nixd/bin/ for package scripts (static)
declare NIXD_ETC    # path to nixd/etc/, conf for package scripts (static)
declare NIXD_SRC    # path to nixd/src/, dest for package resources (static)
declare NIXD_NAME   # name of package script being called (dynamic)
declare NIXD_RES    # base path where package resources are downloaded (dynamic)

# Functions provided to package scripts written in bash.
#
# Silence output in case nixd is calling itself.
declare -f nixd_error                > /dev/null
declare -f nixd_run                  > /dev/null

# Useful variables within this program, set in main function.
declare PROG
declare PROG_DIR

usage() {
    # Print nixd program usage to stderr and exit with status code 1.

    exec >&2 # Redirect all further stdout to stderr.

    if [ $# -gt 0 ]; then
        # Print message argument, if given.
        echo "$@"
        echo
    fi

    echo "usage: $PROG <command>"
    echo
    echo "Configuration variables:"
    print_environment
    echo
    echo "Commands:"
    echo "boot     - Fully initialize stack specified in configuration."
    echo "download - Download all resources specified in configuration."
    exit 1
}


# Begin functions exported to package scripts written in bash.
#
# Note that these scripts run in a separate bash process.

nixd_error() {
    # Print given message to stderr and exit with status code 2.

    echo "$@" >&2
    exit 2
}

nixd_run() {
    # A main routine usable by package scripts written in bash.

    local command=$1
    shift

    local command_type=`type -t $command`

    # Exit immediately if a command error occurs.
    set -e

    if [ -z "$command_type" ]; then
        nixd_error "$NIXD_NAME: $command is not implemented."
    elif [ "$command_type" != "function" ]; then
        nixd_error "$NIXD_NAME: $command is not a valid command."
    fi

    $command "$@"
}


# Begin per-package functions.
#
# Each function here follows the same convention: take the path to the package
# script executable as an argument, and if no argument is given, print a short
# (typically one word) user-friendly label of the function's purpose -- to
# support introspection.

boot_package() {
    # Downloads resources specified by `exe resources` then runs `exe install`.
    #
    # The install subcommand runs in directory where resources are downloaded.
    # Does nothing if `exe check` reports success (0 status).

    local exe=$1
    shift

    if [ -z "$exe" ]; then
        echo boot # declare this function's purpose
        return
    fi

    echo "$NIXD_NAME: checking..."
    if ( $exe check ); then
        echo "$NIXD_NAME: already configured."
    else
        download_package_resources $exe
        install_package $exe
    fi
}

download_package_resources() {
    # Download resources specified by the package script's 'resource' command.
    #
    # Resources are specified by `exe resources`, providing via stdout newline
    # (\n) delimited URLs with an optional local name, in the format of one of:
    #
    #     <url>
    #     <url><space><local name>
    #
    # For example:
    #
    #     http://example.com/package.tar.gz
    #     http://example.com/1.0/package.tar.gz package-1.0.tar.gz
    #
    # In the first case, the remote name of package.tar.gz is used locally. In
    # the second case, the remote file is downloaded locally to a file named
    # package-1.0.tar.gz.

    local exe=$1
    shift

    if [ -z "$exe" ]; then
        echo download # declare this function's purpose
        return
    fi

    local resources=$( $exe resources )

    if [ -z "$resources" ]; then
        echo "$NIXD_NAME: no resources to download."
        return 0
    fi

    echo "$NIXD_NAME: resources:"
    echo "$resources"

    mkdir -p $NIXD_RES

    pushd $NIXD_RES > /dev/null

    # Download each resource.
    map_lines download_resource "$resources"

    # Count the number of lines.
    local -i count=`echo "$resources" | wc -l`

    if [ $count -eq 1 ]; then
        echo "$NIXD_NAME: finished download, 1 resource."
    else
        echo "$NIXD_NAME: finished download, $count resources."
    fi

    popd > /dev/null
}

download_resource() {
    # Peform download, run for each line in the resources output.

    # Understanding arrays in bash:
    #
    # Mind the syntax. Set and access as follows.
    #
    #     array=( some things )
    #     ${array[*]} # "some things"
    #     ${array[0]} # "some"
    #     ${array[1]} # "things"
    #     ${array[2]} # ""
    #
    # Get array length with ${#array[@]}.

    # Full line is passed in as argument.
    local resource=$@

    # Pull tokens into array.
    local tokens=( $resource )

    # Flight check.
    if [ ${#tokens[@]} -eq 0 ]; then
        nixd_error "$NIXD_NAME: No argument given to `download_resource`."
    elif [ ${#tokens[@]} -gt 2 ]; then
        nixd_error "$NIXD_NAME: resource error - more than 2 fields: $resource"
    fi

    # Parse tokens.
    local url=${tokens[0]}
    local local_name=${tokens[1]}

    # Parse remote name from URL.
    local remote_name="$( basename "$url" )"

    # If local name is not given, use remote name.
    if [ -z "$local_name" ]; then
        local_name=$remote_name
    fi

    # Swap out given URL with mirror if configured.
    if [ -n "$NIXD_MIRROR" ]; then
        url=$NIXD_MIRROR/$NIXD_NAME/$local_name
    fi

    if [ -e $local_name ]; then
        echo "$NIXD_NAME: using existing $local_name"
    else
        echo "$NIXD_NAME: downloading $local_name from $url"
        curl -L -o $local_name $url # Use '-L' to follow redirects.
    fi
}

install_package() {
    # Run `exe install` in the package's resource directory.
    #
    # This resource directory will have anything downloaded for the package,
    # and is still created if no resources are needed, to allow the package
    # script to create any scratch or temporary files.

    local exe=$1
    shift

    if [ -z "$exe" ]; then
        echo install # declare this function's purpose
        return
    fi

    mkdir -p $NIXD_RES
    pushd $NIXD_RES > /dev/null

    echo "$NIXD_NAME: installing..."
    $exe install

    local result=$?
    if [ $result -eq 0 ]; then
        echo "$NIXD_NAME: installed."
    else
        echo "$NIXD_NAME: install had non-zero status: $result"
    fi

    popd > /dev/null
    return $result
}


# Begin utilities for managing Orderfile (specify dependency order).

list_make_targets() {
    # Print targets found within given makefile.

    local makefile=$1
    shift

    # Parse make database, with pipeline to reduce output to just target names.
    #
    # Discard stderr during this query, to prevent any messages to the effect
    # of "No rule to make...", given that we are querying a makefile fragment.
    make --file $makefile \
        --dry-run \
        --no-builtin-rules \
        --no-builtin-variables \
        --print-data-base 2>/dev/null  | \
            # Skip everything until Files section of make's output.
            sed -rn '/# Files/,$p' | \
            # Remove files listed which are not targets.
            # make --print-data-base lists '# Not a target:' above filenames.
            sed -n '/Not a target/,+1d;p' | \
            # Strip out comments, built-in targets, pattern rules, and
            # potentially blank lines.
            sed -ne '/^[^# \t\.%]/p' | \
            # Trim down to just target name.
            sed -ne 's/:.*$//p'
}

write_makefile() {
    # Expand Orderfile to a full Makefile.

    local orderfile=$NIXD_BIN/Orderfile
    local targets=`list_make_targets $orderfile`
    targets=`echo $targets` # Remove newlines.

    # Check if Orderfile specifies all target, which is an error.
    for target in $targets; do
        if [ "$target" = "all" ]; then
            nixd_error "$PROG: Orderfile cannot specify 'all' target."
        fi
    done

    # Combine everything in a subshell, redirected to Makefile at end.
    (
        echo '# Do not edit, generated by nixd. Edit Orderfile instead.';
        echo
        cat $orderfile;
        echo
        echo '# Ensure ordered targets execute first.'
        echo '# General targets execute in arbitrary order.'
        echo "all: _ordered_tiers $targets"
        echo
        echo '_ordered_tiers: first second third fourth fifth'
        echo
        echo '%:'
        echo '	$(NIXD_BIN)/nixd boot $(NIXD_BIN)/$@'
        echo
        echo '.PHONY: all _ordered_tiers first second third fourth fifth'
    ) > $NIXD_BIN/Makefile
}

handle_boot_order() {
    # If an Orderfile exists, run boot against the given order.
    #
    # Note that the Orderfile is only used for the boot command.
    #
    # Run this first when executing the top-level 'boot' command, then boot
    # with all scripts. This will guarantee that the ordered scripts are run
    # first, then all scripts are run together. Scripts which have ordering
    # requirements should complete on the first run, and 'check' should
    # indicate on the second run that no further work is needed.

    if [ ! -e $NIXD_BIN/Orderfile ]; then
        # No ordered work is needed.
        return
    fi

    echo "$PROG: Handling order specified in Orderfile."
    write_makefile
    make -f $NIXD_BIN/Makefile all
    echo
    echo
    echo "$PROG: Now iterating through all scripts."
}


# Begin essential utilities for nixd main program.

map_scripts() {
    # Execute <first_argument> for each executable in <second_argument> string.
    #
    # This is useful in mapping the given function to all executables in the
    # nixd bin directory. Note that the executable paths must be absolute if
    # current working directory changes during the execution of the mapped
    # function.
    #
    # For each executable found, run: `command path/to/executable`.

    local command=$1
    shift

    local label=`$command`

    local count=0
    for exe in $@; do
        export NIXD_NAME="$( basename "$exe" )"
        export NIXD_RES=$NIXD_SRC/$NIXD_NAME

        # Skip reserved keywords: nixd, order, Makefile, all.
        if [ "$NIXD_NAME" = "$PROG" ]; then
            continue
        elif [ "$NIXD_NAME" = "Orderfile" ]; then
            continue
        elif [ "$NIXD_NAME" = "Makefile" ]; then
            continue
        elif [ "$NIXD_NAME" = "all" ]; then
            continue
        fi

        if [ -x $exe ]; then
            let count=count+1
            export NIXD_NAME="$( basename "$exe" )"
            $command $exe
        else
            echo "$NIXD_NAME: $exe is not executable. Skipping."
        fi
    done

    if [ $count -eq 0 ]; then
        echo "$PROG: nothing to run. No scripts found in $NIXD_BIN."
        return 1
    elif [ $count -eq 1 ]; then
        echo "$PROG: finished $label with $count package."
    else
        echo "$PROG: finished $label with $count packages."
    fi
}

map_lines() {
    # Execute <first_argument> for each line in <second_argument> string.
    #
    # Understanding the internal field separator (IFS) in bash:
    #
    # The IFS is used in word splitting. To split across lines in a string, a
    # for-loop can simply iterate across that string with IFS set to the
    # newline character. IFS must be restored to support normal operation of
    # any further commands.

    local line_function=$1
    local lines="$2"
    shift 2

    local OLD_IFS="$IFS"
    local NEW_IFS=$'\n' # Specifying ANSI escaped char requires $'string' form.

    IFS="$NEW_IFS"
    local count=0
    for line in $lines; do
        IFS="$OLD_IFS"
        $line_function $line
        IFS="$NEW_IFS"
    done
    IFS="$OLD_IFS"
}

print_environment() {
    # Print static environment variables to stdout.

    echo "NIXD_PREFIX: $NIXD_PREFIX"
    echo "NIXD_BIN:    $NIXD_BIN"
    echo "NIXD_ETC:    $NIXD_ETC"
    echo "NIXD_SRC:    $NIXD_SRC"
    echo "NIXD_MIRROR: $NIXD_MIRROR"
}

check_requirements() {
    # Verify that nixd requirements are installed.

    for program in basename dirname curl wc make sed; do
        if ( ! which $program > /dev/null ); then
            echo "$PROG: requires '$program' program, but could not find it."
            return 1
        fi
    done
}


# Begin user-exposed subcommands.

boot() {
    # Find all package scripts, download their resources, then install them.

    if [ $# -eq 0 ]; then
        # Check first for an Orderfile, and execute it.
        handle_boot_order

        # Run all scripts in nixd's bin directory.
        map_scripts boot_package $NIXD_BIN/*
    else
        map_scripts boot_package "$@"
    fi
}

download() {
    # Find all package scripts and download their resources.
    if [ $# -eq 0 ]; then
        map_scripts download_package_resources $NIXD_BIN/*
    else
        map_scripts download_package_resources "$@"
    fi
}


# Begin main script.

main() {
    # The main routine of the nixd program itself.

    PROG="$( basename "${BASH_SOURCE[0]}" )"
    local script_dir="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    PROG_DIR="$( dirname "$script_dir" )"
    NIXD_PREFIX=$PROG_DIR/usr
    NIXD_BIN=$PROG_DIR/bin
    NIXD_ETC=$PROG_DIR/etc
    NIXD_SRC=$PROG_DIR/src

    # Print usage and exit if there are no arguments.
    if [ $# -eq 0 ]; then
        usage
    fi

    local command=$1
    shift

    if [ "`type -t $command`" != "function" ]; then
        usage "$PROG: $command is not a valid command."
    fi

    # Exit immediately if a command error occurs.
    set -e

    check_requirements

    # Export nixd environment variables for use in package scripts.
    export NIXD_PREFIX NIXD_BIN NIXD_ETC
    print_environment

    # Export utility functions for use in package scripts written in bash.
    export -f nixd_error nixd_run

    $command "$@"
}

main "$@"
